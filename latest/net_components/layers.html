<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Layers · MIPVerify.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MIPVerify.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../tutorials.html">Tutorials</a></li><li><a class="toctext" href="../finding_adversarial_examples.html">Finding Adversarial Examples</a></li><li><span class="toctext">Working with Neural Net Parameters</span><ul><li><a class="toctext" href="overview.html">Overview</a></li><li class="current"><a class="toctext" href="layers.html">Layers</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Public-Interface-1">Public Interface</a></li><li><a class="toctext" href="#Internal-1">Internal</a></li></ul></li><li><a class="toctext" href="nets.html">Networks</a></li><li><a class="toctext" href="core_ops.html">Core Operations</a></li></ul></li><li><span class="toctext">Importing</span><ul><li><a class="toctext" href="../utils/import_weights.html">Importing Parameter Values</a></li><li><a class="toctext" href="../utils/import_datasets.html">Importing External Datasets</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Working with Neural Net Parameters</li><li><a href="layers.html">Layers</a></li></ul><a class="edit-page" href="https://github.com/vtjeng/MIPVerify.jl/blob/master/docs/src/net_components/layers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Layers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Layers-1" href="#Layers-1">Layers</a></h1><p>Each layer in the neural net corresponds to a <code>struct</code> that simultaneously specifies: 1) the operation being carried out in the layer (recorded in the _type_ of the <code>struct</code>) and 2) the parameters for the operation (recorded in the values of the fields of the <code>struct</code>).</p><p>When we pass an input array of real numbers to a layer <code>struct</code>, we get an output array of real numbers that is the result of the layer operating on the input.</p><p>Conversely, when we pass an input array of <code>JuMP</code> variables, we get an output array of <code>JuMP</code> variables, with the appropriate mixed-integer constraints (as determined by the layer) imposed between the input and output.</p><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="layers.html#MIPVerify.MaxPool-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}}}} where N"><code>MIPVerify.MaxPool</code></a></li><li><a href="layers.html#MIPVerify.conv2d-Union{Tuple{Array{T,4},MIPVerify.Conv2d{U,V,V} where V&lt;:Int64}, Tuple{T}, Tuple{U}, Tuple{V}} where V&lt;:Union{JuMP.AbstractJuMPScalar, Real} where U&lt;:Union{JuMP.AbstractJuMPScalar, Real} where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}"><code>MIPVerify.conv2d</code></a></li><li><a href="layers.html#MIPVerify.flatten-Union{Tuple{Array{T,N},AbstractArray{U,N} where N}, Tuple{N}, Tuple{T}, Tuple{U}} where U&lt;:Int64 where N where T"><code>MIPVerify.flatten</code></a></li><li><a href="layers.html#MIPVerify.getoutputsize-Union{Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T"><code>MIPVerify.getoutputsize</code></a></li><li><a href="layers.html#MIPVerify.getpoolview-Union{Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T"><code>MIPVerify.getpoolview</code></a></li><li><a href="layers.html#MIPVerify.getsliceindex-Tuple{Int64,Int64,Int64}"><code>MIPVerify.getsliceindex</code></a></li><li><a href="layers.html#MIPVerify.matmul-Tuple{Array{#s133,1} where #s133&lt;:Union{JuMP.AbstractJuMPScalar, Real},MIPVerify.Linear}"><code>MIPVerify.matmul</code></a></li><li><a href="layers.html#MIPVerify.pool-Union{Tuple{AbstractArray{T,N},MIPVerify.Pool{N}}, Tuple{N}, Tuple{T}} where N where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}"><code>MIPVerify.pool</code></a></li><li><a href="layers.html#MIPVerify.poolmap-Union{Tuple{Function,AbstractArray{T,N},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T"><code>MIPVerify.poolmap</code></a></li><li><a href="layers.html#MIPVerify.Conv2d"><code>MIPVerify.Conv2d</code></a></li><li><a href="layers.html#MIPVerify.Conv2d-Union{Tuple{Array{T,4}}, Tuple{T}} where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}"><code>MIPVerify.Conv2d</code></a></li><li><a href="layers.html#MIPVerify.Flatten"><code>MIPVerify.Flatten</code></a></li><li><a href="layers.html#MIPVerify.Linear"><code>MIPVerify.Linear</code></a></li><li><a href="layers.html#MIPVerify.MaskedReLU"><code>MIPVerify.MaskedReLU</code></a></li><li><a href="layers.html#MIPVerify.Pool"><code>MIPVerify.Pool</code></a></li><li><a href="layers.html#MIPVerify.ReLU"><code>MIPVerify.ReLU</code></a></li></ul><h2><a class="nav-anchor" id="Public-Interface-1" href="#Public-Interface-1">Public Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Conv2d" href="#MIPVerify.Conv2d"><code>MIPVerify.Conv2d</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct Conv2d{T&lt;:Union{JuMP.AbstractJuMPScalar, Real}, U&lt;:Union{JuMP.AbstractJuMPScalar, Real}, V&lt;:Int64} &lt;: MIPVerify.Layer</code></pre><p>Represents 2-D convolution operation.</p><p><code>p(x)</code> is shorthand for <a href="layers.html#MIPVerify.conv2d-Union{Tuple{Array{T,4},MIPVerify.Conv2d{U,V,V} where V&lt;:Int64}, Tuple{T}, Tuple{U}, Tuple{V}} where V&lt;:Union{JuMP.AbstractJuMPScalar, Real} where U&lt;:Union{JuMP.AbstractJuMPScalar, Real} where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}"><code>conv2d(x, p)</code></a> when <code>p</code> is an instance of <code>Conv2d</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>filter</code></p></li><li><p><code>bias</code></p></li><li><p><code>stride</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/conv2d.jl#L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Conv2d-Union{Tuple{Array{T,4}}, Tuple{T}} where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}" href="#MIPVerify.Conv2d-Union{Tuple{Array{T,4}}, Tuple{T}} where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}"><code>MIPVerify.Conv2d</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">Conv2d(filter)
</code></pre><p>Convenience function to create a <a href="layers.html#MIPVerify.Conv2d"><code>Conv2d</code></a> struct with the specified filter and zero bias.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/conv2d.jl#L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Flatten" href="#MIPVerify.Flatten"><code>MIPVerify.Flatten</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct Flatten{T&lt;:Int64} &lt;: MIPVerify.Layer</code></pre><p>Represents a flattening operation.</p><p><code>p(x)</code> is shorthand for <a href="layers.html#MIPVerify.flatten-Union{Tuple{Array{T,N},AbstractArray{U,N} where N}, Tuple{N}, Tuple{T}, Tuple{U}} where U&lt;:Int64 where N where T"><code>flatten(x, p.perm)</code></a> when <code>p</code> is an instance of <code>Flatten</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>n_dim</code></p></li><li><p><code>perm</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/flatten.jl#L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Linear" href="#MIPVerify.Linear"><code>MIPVerify.Linear</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct Linear{T&lt;:Real, U&lt;:Real} &lt;: MIPVerify.Layer</code></pre><p>Represents matrix multiplication.</p><p><code>p(x)</code> is shorthand for <a href="layers.html#MIPVerify.matmul-Tuple{Array{#s133,1} where #s133&lt;:Union{JuMP.AbstractJuMPScalar, Real},MIPVerify.Linear}"><code>matmul(x, p)</code></a> when <code>p</code> is an instance of <code>Linear</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>matrix</code></p></li><li><p><code>bias</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/linear.jl#L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.MaskedReLU" href="#MIPVerify.MaskedReLU"><code>MIPVerify.MaskedReLU</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct MaskedReLU{T&lt;:Real} &lt;: MIPVerify.Layer</code></pre><p>Represents a masked ReLU activation, with <code>mask</code> controlling how the ReLU is applied to each output.</p><p><code>p(x)</code> is shorthand for <a href="core_ops.html#MIPVerify.masked_relu-Tuple{AbstractArray{#s30,N} where N where #s30&lt;:JuMP.AbstractJuMPScalar,AbstractArray{#s29,N} where N where #s29&lt;:Real}"><code>masked_relu(x, p.mask)</code></a> when <code>p</code> is an instance of <code>MaskedReLU</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>mask</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/masked_relu.jl#L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.MaxPool-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}}}} where N" href="#MIPVerify.MaxPool-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}}}} where N"><code>MIPVerify.MaxPool</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">MaxPool(strides)
</code></pre><p>Convenience function to create a <a href="layers.html#MIPVerify.Pool"><code>Pool</code></a> struct for max-pooling.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/pool.jl#L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.Pool" href="#MIPVerify.Pool"><code>MIPVerify.Pool</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct Pool{N} &lt;: MIPVerify.Layer</code></pre><p>Represents a pooling operation.</p><p><code>p(x)</code> is shorthand for <a href="layers.html#MIPVerify.pool-Union{Tuple{AbstractArray{T,N},MIPVerify.Pool{N}}, Tuple{N}, Tuple{T}} where N where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}"><code>pool(x, p)</code></a> when <code>p</code> is an instance of <code>Pool</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>strides</code></p></li><li><p><code>pooling_function</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/pool.jl#L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.ReLU" href="#MIPVerify.ReLU"><code>MIPVerify.ReLU</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">struct ReLU &lt;: MIPVerify.Layer</code></pre><p>Represents a ReLU operation.</p><p><code>p(x)</code> is shorthand for <a href="core_ops.html#MIPVerify.relu-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T&lt;:JuMP.AbstractJuMPScalar"><code>relu(x)</code></a> when <code>p</code> is an instance of <code>ReLU</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/relu.jl#L3">source</a></section><h2><a class="nav-anchor" id="Internal-1" href="#Internal-1">Internal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.conv2d-Union{Tuple{Array{T,4},MIPVerify.Conv2d{U,V,V} where V&lt;:Int64}, Tuple{T}, Tuple{U}, Tuple{V}} where V&lt;:Union{JuMP.AbstractJuMPScalar, Real} where U&lt;:Union{JuMP.AbstractJuMPScalar, Real} where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}" href="#MIPVerify.conv2d-Union{Tuple{Array{T,4},MIPVerify.Conv2d{U,V,V} where V&lt;:Int64}, Tuple{T}, Tuple{U}, Tuple{V}} where V&lt;:Union{JuMP.AbstractJuMPScalar, Real} where U&lt;:Union{JuMP.AbstractJuMPScalar, Real} where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}"><code>MIPVerify.conv2d</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">conv2d(input, params)
</code></pre><p>Computes the result of convolving <code>input</code> with the <code>filter</code> and <code>bias</code> stored in <code>params</code>.</p><p>Mirrors <code>tf.nn.conv2d</code> from the <code>tensorflow</code> package, with <code>strides = [1, 1, 1, 1],  padding = &#39;SAME&#39;</code>.</p><p><strong>Throws</strong></p><ul><li><p>AssertionError if <code>input</code> and <code>filter</code> are not compatible.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/conv2d.jl#L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.flatten-Union{Tuple{Array{T,N},AbstractArray{U,N} where N}, Tuple{N}, Tuple{T}, Tuple{U}} where U&lt;:Int64 where N where T" href="#MIPVerify.flatten-Union{Tuple{Array{T,N},AbstractArray{U,N} where N}, Tuple{N}, Tuple{T}, Tuple{U}} where U&lt;:Int64 where N where T"><code>MIPVerify.flatten</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Permute dimensions of array in specified order, then flattens the array.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/flatten.jl#L48-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.matmul-Tuple{Array{#s133,1} where #s133&lt;:Union{JuMP.AbstractJuMPScalar, Real},MIPVerify.Linear}" href="#MIPVerify.matmul-Tuple{Array{#s133,1} where #s133&lt;:Union{JuMP.AbstractJuMPScalar, Real},MIPVerify.Linear}"><code>MIPVerify.matmul</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">matmul(x, params)
</code></pre><p>Computes the result of pre-multiplying <code>x</code> by the transpose of <code>params.matrix</code> and adding <code>params.bias</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/linear.jl#L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.getoutputsize-Union{Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T" href="#MIPVerify.getoutputsize-Union{Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T"><code>MIPVerify.getoutputsize</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">getoutputsize(input_array, strides)
</code></pre><p>For pooling operations on an array, returns the expected size of the output array.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/pool.jl#L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.getpoolview-Union{Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T" href="#MIPVerify.getpoolview-Union{Tuple{AbstractArray{T,N},Tuple{Vararg{Int64,N}},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T"><code>MIPVerify.getpoolview</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">getpoolview(input_array, strides, output_index)
</code></pre><p>For pooling operations on an array, returns a view of the parent array corresponding to the <code>output_index</code> in the output array.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/pool.jl#L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.getsliceindex-Tuple{Int64,Int64,Int64}" href="#MIPVerify.getsliceindex-Tuple{Int64,Int64,Int64}"><code>MIPVerify.getsliceindex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">getsliceindex(input_array_size, stride, output_index)
</code></pre><p>For pooling operations on an array where a given element in the output array corresponds to equal-sized blocks in the input array, returns (for a given dimension) the index range in the input array corresponding to a particular index <code>output_index</code> in the output array.</p><p>Returns an empty array if the <code>output_index</code> does not correspond to any input indices.</p><p><strong>Arguments</strong></p><ul><li><p><code>stride::Integer</code>: the size of the operating blocks along the active    dimension.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/pool.jl#L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.pool-Union{Tuple{AbstractArray{T,N},MIPVerify.Pool{N}}, Tuple{N}, Tuple{T}} where N where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}" href="#MIPVerify.pool-Union{Tuple{AbstractArray{T,N},MIPVerify.Pool{N}}, Tuple{N}, Tuple{T}} where N where T&lt;:Union{JuMP.AbstractJuMPScalar, Real}"><code>MIPVerify.pool</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">pool(input, params)
</code></pre><p>Computes the result of applying the pooling function <code>params.pooling_function</code> to  non-overlapping cells of <code>input</code> with sizes specified in <code>params.strides</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/pool.jl#L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MIPVerify.poolmap-Union{Tuple{Function,AbstractArray{T,N},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T" href="#MIPVerify.poolmap-Union{Tuple{Function,AbstractArray{T,N},Tuple{Vararg{Int64,N}}}, Tuple{N}, Tuple{T}} where N where T"><code>MIPVerify.poolmap</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">poolmap(f, input_array, strides)
</code></pre><p>Returns output from applying <code>f</code> to subarrays of <code>input_array</code>, with the windows determined by the <code>strides</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/vtjeng/MIPVerify.jl/blob/1f5c052879cd79342a5e5db0450d67a673fba913/src/net_components/layers/pool.jl#L94">source</a></section><footer><hr/><a class="previous" href="overview.html"><span class="direction">Previous</span><span class="title">Overview</span></a><a class="next" href="nets.html"><span class="direction">Next</span><span class="title">Networks</span></a></footer></article></body></html>
